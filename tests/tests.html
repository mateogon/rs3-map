<!DOCTYPE html>
<html>
<head>
    <title>Mejrs Map Tests</title>
    <!-- Mock Leaflet for headless testing if needed, or just include real one -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.2.0/leaflet.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.2.0/leaflet.css" />

    <style>
        body { font-family: sans-serif; padding: 20px; }
        .pass { color: green; }
        .fail { color: red; font-weight: bold; }
        .test-case { margin-bottom: 5px; }
    </style>
</head>
<body>
    <h1>Unit Tests</h1>
    <div id="results">Running...</div>
    <div id="map" style="height: 100px; width: 100px; display:none;"></div>

    <script type="module">
        import { Position } from '../js/model/Position.js';
        import { Area } from '../js/model/Area.js';
        import { PolyArea } from '../js/model/PolyArea.js';
        // Import maplabels (side effect: registers L.maplabelGroup)
        import '../js/plugins/leaflet.maplabels.js?v=debug1'; 

        const map = L.map('map', {
            zoomControl: false,
            crs: L.CRS.Simple
        });
        map.project = (latlng, zoom) => L.point(latlng.lng, latlng.lat);
        map.unproject = (point, zoom) => L.latLng(point.y, point.x);
        map.getMaxZoom = () => 4;
        map.setView([0, 0], 0);

        const results = document.getElementById('results');
        results.innerHTML = "";
        let passed = 0;
        let failed = 0;

        function assert(condition, message) {
            const div = document.createElement('div');
            div.className = 'test-case ' + (condition ? 'pass' : 'fail');
            div.textContent = (condition ? '[PASS] ' : '[FAIL] ') + message;
            results.appendChild(div);
            if (condition) passed++; else failed++;
        }

        async function runTests() {
            try {
                // TEST 1: Position
                const pos1 = new Position(100, 200, 0);
                assert(pos1.x === 100 && pos1.y === 200, "Position constructor stores values");
                
                const latLng = pos1.toLatLng(map);
                assert(latLng.lat === 200 && latLng.lng === 100, "Position.toLatLng maps correctly (1:1)");

                // TEST 1.1: Position Rounding
                // X.1 should be X
                const posLow = Position.fromLatLng(map, { lng: 3200.1, lat: 3400.1 }, 0);
                assert(posLow.x === 3200 && posLow.y === 3400, "Position rounds down 3200.1 -> 3200");

                // X.9 should be X (with Math.floor)
                const posHigh = Position.fromLatLng(map, { lng: 3200.9, lat: 3400.9 }, 0);
                assert(posHigh.x === 3200 && posHigh.y === 3400, "Position rounds down 3200.9 -> 3200");

                // X.5 should be X
                const posMid = Position.fromLatLng(map, { lng: 3200.5, lat: 3400.5 }, 0);
                assert(posMid.x === 3200 && posMid.y === 3400, "Position rounds down 3200.5 -> 3200");

                // TEST 2: Area
                const area = new Area(new Position(10, 10, 0), new Position(20, 20, 0));
                assert(area.startPosition.x === 10, "Area start position correct");
                const leafRect = area.toLeaflet(map);
                assert(leafRect instanceof L.Rectangle, "Area.toLeaflet returns L.Rectangle");

                // TEST 3: PolyArea (The one that crashed)
                const poly = new PolyArea(map);
                assert(poly.isEmpty(), "PolyArea starts empty");
                
                // Crash reproduction attempt
                try {
                    poly.add(new Position(30, 30, 0));
                    assert(poly.positions.length === 1, "PolyArea added first point without crash");
                } catch (e) {
                    assert(false, "PolyArea.add CRASHED on first point: " + e.message);
                }

                try {
                    poly.add(new Position(40, 40, 0));
                    assert(poly.positions.length === 2, "PolyArea added second point without crash");
                } catch (e) {
                    assert(false, "PolyArea.add CRASHED on second point: " + e.message);
                }
                
                // Verify content
                assert(poly.positions[0].x === 30, "PolyArea point 1 is correct");

                // TEST 4: Map Labels Optimization
                // Mock fetch for the labels
                const mockLabels = { values: [] };
                for(let i=0; i<1000; i++) {
                    mockLabels.values.push([3200 + (i%100), 3200 + (i/100), 0, `Label ${i}`]);
                }
                const originalFetch = window.fetch;
                window.fetch = async () => ({ json: async () => mockLabels });

                try {
                    const labelsLayer = L.maplabelGroup({ API_KEY: 'test', SHEET_ID: 'test' });
                    labelsLayer.addTo(map);

                    // Wait for fetch/add to complete (microtask)
                    await new Promise(r => setTimeout(r, 10));

                    // Trigger zoom animation
                    const start = performance.now();
                    // Ensure center is set for getZoomScale internally if needed? 
                    // But we mocked functions so maybe it's fine.
                    // Let's verify what getZoomScale returns
                    const calculatedScale = map.getZoomScale(3, 2);
                    console.log("Calculated Scale in Test from map.getZoomScale(3, 2):", calculatedScale);

                    map.fire('zoomanim', { zoom: 3, center: map.getCenter() });
                    const end = performance.now();
                    
                    const duration = end - start;
                    const scaleVar = map.getContainer().style.getPropertyValue('--label-scale');
                    console.log("Read --label-scale from container:", scaleVar);
                    console.log("Container style cssText:", map.getContainer().style.cssText);

                    assert(scaleVar !== '', "CSS variable --label-scale was set. Got: '" + scaleVar + "'");
                    // 1000 labels should be instant with CSS variable (e.g. < 5ms), whereas DOM loop would be slower.
                    // We'll be generous with 10ms to account for overhead, but it confirms O(1) mostly.
                    assert(duration < 20, `Zoom anim handler took ${duration.toFixed(2)}ms (expected < 20ms)`);
                    
                    // Verify logic
                    const expectedScale = map.getZoomScale(3, 2); // 2 is from maplabels source
                    assert(Math.abs(parseFloat(scaleVar) - expectedScale) < 0.001, "Scale value is correct");

                } catch(e) {
                    assert(false, "MapLabel optimization test failed: " + e.message);
                } finally {
                    window.fetch = originalFetch;
                }

                // TEST 5: CDN Speed Benchmark
                console.log("Starting CDN Benchmark...");
                // Use a likely existing tile path. 
                // Trying a tile from the surface map icons.
                const testPath = "icon_squares/-1/1/0_32_32.png"; // Near 3200,3200
                
                const oldUrl = `https://raw.githubusercontent.com/mejrs/layers_rs3/refs/heads/master/${testPath}`;
                const newUrl = `https://cdn.jsdelivr.net/gh/mejrs/layers_rs3@master/${testPath}`;

                const benchmark = async (url, label) => {
                    const t0 = performance.now();
                    try {
                        const res = await fetch(url, { method: 'HEAD' }); 
                        if(!res.ok) console.warn(label + " fetch status: " + res.status);
                    } catch(e) {
                        console.warn(label + " error: " + e.message);
                    }
                    return performance.now() - t0;
                };

                // Sequential benchmark
                const tOld = await benchmark(oldUrl, "Old Source");
                const tNew = await benchmark(newUrl, "New Source (CDN)");
                
                // SW Cache Benchmark: Fetch the CDN URL again. 
                // If SW is compliant, this should be effectively instant (< 20ms) or at least memory-cache speed.
                const tCache = await benchmark(newUrl, "SW Cache Hit");

                console.log(`Speed Test Result: Raw=${tOld.toFixed(2)}ms, CDN=${tNew.toFixed(2)}ms, Cache=${tCache.toFixed(2)}ms`);
                
                // Assert reasonable CDN response
                assert(tNew < 2000, `CDN response time is reasonable (${tNew.toFixed(0)}ms)`);
                
                // Assert Cache speed
                // Ideally < 50ms. Allowing 100ms for browser busy-ness.
                if (navigator.serviceWorker && navigator.serviceWorker.controller) {
                    assert(tCache < 100, `Service Worker Cache is fast (${tCache.toFixed(2)}ms)`);
                    assert(tCache < tNew, `Cache (${tCache.toFixed(0)}ms) is faster than Network (${tNew.toFixed(0)}ms)`);
                } else {
                    console.warn("Service Worker not controlling validation page. Skipping Cache assertions.");
                }

                if (tNew > tOld && tOld < 50) {
                     // If both are super fast (local/cached), ignore comparison.
                } else if (tNew > tOld * 2) {
                     console.warn("Warning: CDN was slower in this run.");
                }

                // Summary
                const summary = document.createElement('h2');
                summary.textContent = `Total: ${passed + failed}, Passed: ${passed}, Failed: ${failed}`;
                summary.style.color = failed > 0 ? 'red' : 'green';
                results.prepend(summary);

            } catch (e) {
                assert(false, "Test Suite Crashed: " + e.message);
                console.error(e);
            }
        }

        runTests();
    </script>
</body>
</html>
